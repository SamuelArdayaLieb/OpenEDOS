"""
This is the OpenEDOS SystemBuilder v0.2.
(c) 2024 Samuel Ardaya-Lieb, MIT license

https://github.com/SamuelArdayaLieb/OpenEDOS
"""

from datetime import datetime
from message_handlers import Request, RequestHandler, ResponseHandler
from typing import List, Dict
from user_code import UserCode
import utils

class File():    
    def __init__(self, 
        filename:str, 
        author:str, 
        version:str,
        copyright_notice:str,
        user_codes:Dict[str, UserCode]={}
        ) -> None:
        self.filename = filename
        self.author = author
        self.date = datetime.today().strftime('%Y-%m-%d')
        self.version = version
        self.copyright_notice = copyright_notice
        id = "FILE HEADER"
        self.intro = user_codes[id] if id in user_codes else UserCode(identifier=id)
        self.includes:List[str] = []
        self.sections:List[str] = []
        
    def _includes(self) -> str:
        text = ""
        for include in self.includes:
            text += f"#include {include}\n"
        text += "\n"
        return text

    def _introduction(self) -> str:
        text = f"Created with the OpenEDOS SystemBuilder v{utils.OPENEDOS_SYSTEMBUILDER_VERSION}.\n" 
        text += f"Created for the OpenEDOS Core v{utils.OPENEDOS_CORE_VERSION}.\n\n"
        text += "This file is autogenerated. Sections inside USER CODE BEGIN and USER CODE END\n"\
                "will be left untouched when rerunning the code generation. Happy coding!\n\n"
        text += f"@file {self.filename}\n"
        text += f"@author {self.author}\n"
        text += f"@version {self.version}\n"
        text += f"@date {self.date}\n\n"
        text += self.copyright_notice
        text = utils.text_to_comment(text)
        text += "\n"
        return text
        
    def get_text(self) -> str:
        text = self._introduction()
        text += self.intro.get_text()
        text += "\n"
        for section in self.sections:
            text += section
        return text
    
class InterfaceHeader(File):
    def __init__(
        self, 
        name:str,
        author:str,  
        version:str, 
        copyright_notice:str,
        requests:Dict[str, Request]={},
        user_codes:Dict[str, UserCode]={}
        ) -> None:
        filename = utils.name_to_filename(f"{name}_intf.h")
        super().__init__(
            filename=filename, 
            author=author,  
            version=version, 
            copyright_notice=copyright_notice,
            user_codes=user_codes)
        
        self.name = name
        self.requests = requests

        self.includes = ["\"defines.h\""]
        id = "INTERFACE HEADER"
        self.user_code = user_codes[id] if id in user_codes else UserCode(identifier=id)
        
    def _guard_top(self) -> str:
        text = f"#ifndef {self.filename.replace('.', '_').upper()}\n"
        text += f"#define {self.filename.replace('.', '_').upper()}\n\n"
        return text

    def _guard_bot(self) -> str:
        text = f"#endif//{self.filename.replace('.', '_').upper()}"
        return text

    def _requests(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Requests ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        if len(self.requests) > 0:
            for request in self.requests.values():
                text += request.get_header_text()
        else:
            text += "/* There are no requests associated with this module. */\n\n"
        return text

    def get_text(self) -> str:
        self.sections.append(self._guard_top())
        self.sections.append(self._includes())
        self.sections.append("/* Includes, defines, typedefs, etc. */\n")
        self.sections.append(f"{self.user_code.get_text()}\n")
        self.sections.append(self._requests())
        self.sections.append(self._guard_bot())

        return super().get_text()
    
class InterfaceSource(File):    
    def __init__(
        self, 
        name:str,
        author: str,  
        version: str, 
        copyright_notice: str,
        requests:Dict[str, Request]={},
        user_codes:Dict[str, UserCode]={}
        ) -> None:
        filename = utils.name_to_filename(f"{name}_intf.c")
        super().__init__(
            filename=filename, 
            author=author,  
            version=version, 
            copyright_notice=copyright_notice,
            user_codes=user_codes)
        
        self.name = name
        self.requests = requests

        header_name = utils.name_to_filename(f"{name}_intf.h")
        self.includes = [
            f"\"{header_name}\"",
            "\"kernel_switch.h\""
            ]
        id = "INTERFACE SOURCE"
        self.user_code = user_codes[id] if id in user_codes else UserCode(identifier=id)

    def _requests(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Requests ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        
        if len(self.requests) > 0:
            for request in self.requests.values():
                text += request.get_source_text()
        else:
            text += "/* There are no requests associated with this interface. */\n\n"

        return text

    def get_text(self) -> str:        
        self.sections.append(self._includes())
        self.sections.append(self._requests())
        self.sections.append("\n/* Something else...? */\n")
        self.sections.append(self.user_code.get_text())

        return super().get_text()

class ModuleHeader(File):
    def __init__(
        self, 
        name:str,
        author: str,  
        version: str, 
        copyright_notice: str,
        user_codes:Dict[str, UserCode]={}
        ) -> None:
        filename = utils.name_to_filename(f"{name}_mod.h")
        super().__init__(
            filename=filename, 
            author=author,  
            version=version, 
            copyright_notice=copyright_notice,
            user_codes=user_codes)
        
        self.name = name

        id = "MODULE GLOBALS"
        self.user_code_globals = user_codes[id] if id in user_codes else UserCode(identifier=id)
        id = "MODULE DATA"
        self.user_code_module_data = user_codes[id] if id in user_codes else UserCode(identifier=id)
        self.user_code_module_data.indents = 1
        id = "MODULE PROTOTYPES"
        self.user_code_prototypes = user_codes[id] if id in user_codes else UserCode(identifier=id)

        self.includes = [
            "\"defines.h\""
        ]

    def _guard_top(self) -> str:
        text = f"#ifndef {self.filename.replace('.', '_').upper()}\n"
        text += f"#define {self.filename.replace('.', '_').upper()}\n\n"
        return text

    def _guard_bot(self) -> str:
        text = f"#endif//{self.filename.replace('.', '_').upper()}"
        return text

    def _user_includes(self) -> str:
        text = "/* Includes, typedefs, globals, etc. */\n"
        text += self.user_code_globals.get_text()
        text += "\n"
        return text

    def _module_definition(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~ Module definition ~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        text += f"typedef struct module_{self.name}_s {'{'}\n"
        text += f"\t/* The connection to the kernel. */\n"
        text += f"\tKernel_t *Kernel;\n\n"
        text += f"\t/* Module data. */\n"
        text += self.user_code_module_data.get_text()
        text += f"{'}'} module_{self.name}_t;\n\n"
        return text

    def _init_prototype(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~~~ Init prototype ~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        comment = f"@brief Initialize the module {self.name}.\n\n"
        comment += "This function registers the request handlers of the module\n"
        comment += "and connects the module to the kernel. It then calls the specific\n"
        comment += "init function of the module.\n\n"
        comment += f"@param {self.name} A pointer to the module to be initialized.\n\n"
        comment += "@param Kernel A pointer to the kernel to be connected.\n"
        comment += "\n@return Error_t An error is returned if\n"
        comment += "- initializing the module results in an error.\n"
        comment += "Otherwise ERROR_NONE is returned.\n"
        text += utils.text_to_comment(comment)
        text += f"Error_t initModule_{self.name}(\n"
        text += f"\tmodule_{self.name}_t *{self.name},\n"
        text += f"\tKernel_t *Kernel);\n\n"
        return text

    def _user_prototypes(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~~~ User prototypes ~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        text += self.user_code_prototypes.get_text()
        text += "\n"
        return text

    def get_text(self) -> str:
        self.sections.append(self._guard_top())
        self.sections.append(self._includes())
        self.sections.append(self._user_includes())
        self.sections.append(self._module_definition())
        self.sections.append(self._init_prototype())
        self.sections.append(self._user_prototypes())
        self.sections.append(self._guard_bot())

        return super().get_text()

class ModuleSource(File):
    def __init__(
        self, 
        name:str,
        author: str,  
        version: str, 
        copyright_notice: str,
        request_handlers:Dict[str, RequestHandler]={},
        response_handlers:Dict[str, ResponseHandler]={},
        user_codes:Dict[str, UserCode]={},
        ) -> None:
        filename = utils.name_to_filename(f"{name}_mod.c")
        super().__init__(
            filename=filename, 
            author=author,  
            version=version, 
            copyright_notice=copyright_notice,
            user_codes=user_codes)
        
        self.name = name
        id = "MODULE GLOBALS"
        self.user_code_globals = user_codes[id] if id in user_codes else UserCode(identifier=id)
        id = "MODULE INIT"
        self.user_code_init = user_codes[id] if id in user_codes else UserCode(identifier=id)
        self.user_code_init.indents = 1
        id = "MODULE FUNCTIONS"
        self.user_code_funcs = user_codes[id] if id in user_codes else UserCode(identifier=id)
        self.request_handlers = request_handlers
        self.response_handlers = response_handlers

        headername = utils.name_to_filename(f"{name}_mod.h")
        self.includes = [
            f"\"{headername}\"",
            "\"kernel.h\""
        ]

    def _user_includes(self) -> str:
        text = "/* Includes, prototypes, globals, etc. */\n"
        text += self.user_code_globals.get_text()
        text += "\n"
        return text

    def _global_pointer(self) -> str:
        text = "/* Global pointer to the module. */\n"
        text += f"static module_{self.name}_t *{self.name};\n\n"
        return text
    
    def _init_prototype(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~ Custom init prototype ~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        comment = f"@brief Custom initializer for the module: {self.name}.\n\n"
        if self.user_code_init.description != "\n":
            comment += self.user_code_init.description + "\n"
        comment += "@return Error_t An error is returned if\n"
        comment += "- initializing the module results in an error.\n"
        comment += "Otherwise ERROR_NONE is returned.\n"
        text += utils.text_to_comment(comment)
        text += f"static inline Error_t init{self.name}(void);\n\n"
        return text
    
    def _request_handler_prototypes(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~ Request handler prototypes ~~~~~~~~~~~~~~~~~~~~~//\n\n"
        if len(self.request_handlers) == 0:
            text += "/* This module does not implement any request handlers. */\n\n"
            return text
        for handler in self.request_handlers.values():
            text += handler.get_prototype()
        return text

    def _respone_handler_prototypes(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~ Response handler prototypes ~~~~~~~~~~~~~~~~~~~~~//\n\n"
        if len(self.response_handlers) == 0:
            text += "/* This module does not implement any response handlers. */\n\n"
            return text
        for handler in self.response_handlers.values():
            text += handler.get_prototype()
        return text

    def _module_init(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~ Module initialization ~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        text += "/* Register handlers and initialize the module. */\n"
        text += f"Error_t initModule_{self.name}(\n"
        text += f"\tmodule_{self.name}_t *p{self.name},\n"
        text += f"\tKernel_t *Kernel)\n"
        text += "{\n"
        text += f"\t/* List the requests this module will handle. */\n"
        text += f"\tRequestID_t RequestIDs[] = {'{'}\n"
        for handler in self.request_handlers.values():
            text += f"{utils.INDENT*2}{handler.RID},\n"
        text += f"\t{'}'};\n\n"
        text += f"\t/* List the request handlers accordingly. */\n"
        text += f"\tMessageHandler_t RequestHandlers[] = {'{'}\n"
        for handler in self.request_handlers.values():
            text += f"{utils.INDENT*2}(MessageHandler_t){handler.func_name},\n"
        text += f"\t{'}'};\n\n"
        text += f"\t/* Register the request handlers. */\n"
        text += f"\tError_t Error = Kernel_registerHandlers(\n"
        text += f"{utils.INDENT*2}Kernel,\n"
        text += f"{utils.INDENT*2}RequestIDs,\n"
        text += f"{utils.INDENT*2}RequestHandlers,\n"
        text += f"{utils.INDENT*2}sizeof(RequestIDs)/sizeof(RequestID_t));\n\n"
        text += f"\t/* Check for errors. */\n"
        text += f"\tif(Error != ERROR_NONE)\n"
        text += f"\t{'{'}\n"
        text += f"{utils.INDENT*2}return Error;\n"
        text += f"\t{'}'}\n\n"
        text += f"\t/* Setup the module connections. */\n"
        text += f"\t{self.name} = p{self.name};\n"
        text += f"\t{self.name}->Kernel = Kernel;\n\n"
        text += f"\t/* Initialize the module. */\n"
        text += f"\tError = init{self.name}();\n\n"
        text += f"\t/* Check for errors. */\n"
        text += f"\tif(Error != ERROR_NONE)\n"
        text += f"\t{'{'}\n"
        text += f"{utils.INDENT*2}/* Unregister handlers if an error occured. */\n"
        text += f"{utils.INDENT*2}Kernel_unregisterHandlers(\n"
        text += f"{utils.INDENT*3}Kernel,\n"
        text += f"{utils.INDENT*3}RequestIDs,\n"
        text += f"{utils.INDENT*3}RequestHandlers,\n"
        text += f"{utils.INDENT*3}sizeof(RequestIDs)/sizeof(RequestID_t));\n\n"
        text += f"{utils.INDENT*2}return Error;\n"
        text += f"\t{'}'}\n\n"
        text += f"\t/* Nice, we're done here. */\n"
        text += f"\treturn ERROR_NONE;\n"
        text += "}\n\n"
        return text
    
    def _custom_init(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~~ Custom init function ~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        text += f"Error_t init{self.name}(void)\n"
        text += "{\n"    
        if self.user_code_init.code == "\n":
            self.user_code_init.code = f"\n\n\t/* Return no error if everything is fine. */\n"
            self.user_code_init.code += "\treturn ERROR_NONE;\n"
        text += self.user_code_init.get_text()    
        text += "}\n\n"
        return text

    def _requests(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~~~ Request handlers ~~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        if len(self.request_handlers) > 0:
            for handler in self.request_handlers.values():
                text += f"{handler.get_body()}"
        else:
            text += "/* This module does not implement any request handlers. */\n\n"
        return text
    
    def _responses(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~~~ Response handlers ~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        if len(self.response_handlers) > 0:
            for handler in self.response_handlers.values():
                text += f"{handler.get_body()}\n"
        else:
            text += "/* This module does not implement any response handlers. */\n\n"
        return text
    
    def _user_funcs(self) -> str:
        text = "//~~~~~~~~~~~~~~~~~~~~~~~~~~~ User functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~//\n\n"
        text += self.user_code_funcs.get_text()
        text += "\n"
        return text

    def get_text(self) -> str:
        self.sections.append(self._includes())
        self.sections.append(self._user_includes())
        self.sections.append(self._global_pointer())
        self.sections.append(self._init_prototype())
        self.sections.append(self._request_handler_prototypes())
        self.sections.append(self._respone_handler_prototypes())
        self.sections.append(self._module_init())
        self.sections.append(self._custom_init())
        self.sections.append(self._requests())
        self.sections.append(self._responses())
        self.sections.append(self._user_funcs())

        return super().get_text()